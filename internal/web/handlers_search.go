package web

import (
	"html/template"
	"log/slog"
	"net/http"
	"strings"

	"github.com/google/uuid"

	"github.com/exedev/docstor/internal/auth"
	"github.com/exedev/docstor/internal/docs"
)

type SearchPageData struct {
	PageData
	Query    string
	Results  []docs.SearchResult
	Filters  SearchFiltersData
	Clients  []ClientOption
}

type SearchFiltersData struct {
	ClientID string
	DocType  string
}

func (s *Server) handleSearch(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	tenant := auth.TenantFromContext(ctx)

	query := strings.TrimSpace(r.URL.Query().Get("q"))
	clientIDStr := r.URL.Query().Get("client_id")
	docTypeStr := r.URL.Query().Get("doc_type")

	// Load clients for filter dropdown
	clientsList, _ := s.clients.List(ctx, tenant.ID)
	var clientOptions []ClientOption
	for _, c := range clientsList {
		selected := clientIDStr != "" && c.ID.String() == clientIDStr
		clientOptions = append(clientOptions, ClientOption{
			ID:       c.ID,
			Name:     c.Name,
			Code:     c.Code,
			Selected: selected,
		})
	}

	pageData := SearchPageData{
		PageData: s.newPageData(r),
		Query:    query,
		Filters: SearchFiltersData{
			ClientID: clientIDStr,
			DocType:  docTypeStr,
		},
		Clients: clientOptions,
	}
	pageData.Title = "Search - Docstor"

	if query == "" {
		s.templates.ExecuteTemplate(w, "search.html", pageData)
		return
	}

	// Build filters
	var filters docs.SearchFilters
	if clientIDStr != "" {
		cid, err := uuid.Parse(clientIDStr)
		if err == nil {
			filters.ClientID = &cid
		}
	}
	if docTypeStr != "" {
		dt := docs.DocType(docTypeStr)
		filters.DocType = &dt
	}

	results, err := s.docs.Search(ctx, tenant.ID, query, filters, 50)
	if err != nil {
		slog.Error("search failed", "error", err, "query", query)
		pageData.Error = "Search failed. Please try again."
		s.templates.ExecuteTemplate(w, "search.html", pageData)
		return
	}

	// Filter by sensitivity
	mem := auth.MembershipFromContext(ctx)
	if mem != nil {
		var filtered []docs.SearchResult
		for _, sr := range results {
			if docs.CanAccess(mem.Role, sr.Sensitivity) {
				filtered = append(filtered, sr)
			}
		}
		results = filtered
	}

	// Mark headlines as safe HTML (they're generated by postgres with our markers)
	for i := range results {
		results[i].Headline = sanitizeHeadline(results[i].Headline)
	}

	pageData.Results = results
	pageData.Title = "Search: " + query + " - Docstor"

	s.templates.ExecuteTemplate(w, "search.html", pageData)
}

// sanitizeHeadline ensures only our <mark> tags remain, escaping anything else
func sanitizeHeadline(headline string) string {
	// The headline from postgres uses <mark> and </mark>
	// We want to keep those but escape everything else
	// Since we control the markers in the query, this is safe
	return headline
}

// HeadlineSafe returns the headline as template.HTML for rendering
func HeadlineSafe(headline string) template.HTML {
	return template.HTML(headline)
}
